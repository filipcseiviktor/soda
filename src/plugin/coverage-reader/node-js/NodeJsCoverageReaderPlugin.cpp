/*
 * Copyright (C): 2017 Department of Software Engineering, University of Szeged
 *
 * Authors: Tam√°s Gergely <gertom@inf.u-szeged.hu>
 *
 * This file is part of SoDA.
 *
 *  SoDA is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  SoDA is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with SoDA.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <iostream>
#include <fstream>

#include "exception/CException.h"
#include "NodeJsCoverageReaderPlugin.h"

#include "boost/algorithm/string.hpp"
#include "boost/property_tree/ptree.hpp"
#include "boost/regex.hpp"
#include "rapidjson/document.h"
#include "rapidjson/istreamwrapper.h"

namespace pt = boost::property_tree;

namespace soda {

NodeJsCoverageReaderPlugin::NodeJsCoverageReaderPlugin() :
    m_coverage(NULL), m_granularity(CHAIN)
{}

NodeJsCoverageReaderPlugin::~NodeJsCoverageReaderPlugin()
{}

std::string NodeJsCoverageReaderPlugin::getName()
{
    return "node-js";
}

std::string NodeJsCoverageReaderPlugin::getDescription()
{
    return "Reads coverage from JSON files generated by NodeJS.";
}

CCoverageMatrix* NodeJsCoverageReaderPlugin::read(const variables_map &vm)
{
    m_codeElementNameFilter.assign(vm["cut-source-path"].as<String>());

    // Set the required granularity level
    if (vm.count("granularity")) {
        String granularity = vm["granularity"].as<String>();

        if (granularity == "method") {
            m_granularity = METHOD;
        } else if (granularity == "chain") {
            m_granularity = CHAIN;
        }
    }

    m_coverage = new CCoverageMatrix();

    readFromDirectoryStructure(vm["path"].as<String>());

    return m_coverage;
}

void NodeJsCoverageReaderPlugin::readFromDirectoryStructure(const char * dirname)
{
    fs::path coverage_path(dirname);

    if (!fs::exists(coverage_path)) {
        throw CException("NodeJsCoverageReaderPlugin::readFromDirectoryStructure()", "The specified path does not exists.");
    }

    if (!fs::is_directory(coverage_path)) {
        throw CException("NodeJsCoverageReaderPlugin::readFromDirectoryStructure()", "The specified path is not a directory.");
    }

    readFromDirectory(coverage_path);
}

void NodeJsCoverageReaderPlugin::readFromDirectoryStructure(const std::string& dirname)
{
    readFromDirectoryStructure(dirname.c_str());
}

void NodeJsCoverageReaderPlugin::readFromDirectory(fs::path path)
{
    static int info_tcnt = 0; //INFO
    static int info_tmax = 0;
    int info_cnt = 0; //INFO
    int info_max;

    std::cout << "Processing directory: " << path << std::endl;
    std::cout.flush();

    std::vector<fs::path> pathVector;

    std::copy(fs::directory_iterator(path), fs::directory_iterator(), std::back_inserter(pathVector));
    std::sort(pathVector.begin(), pathVector.end());

    info_tmax += info_max = pathVector.size();

    for (auto it = pathVector.begin(); it != pathVector.end(); ++it) {
        if (fs::is_directory(*it)) { // recurse into subdirs
            if (fs::basename(*it) != "") {
                readFromDirectory(*it);
            } else {
                info_tmax--;
                info_max--;
            }
        } else {
            std::cout << info_cnt++ << "/" << info_max << ' ' << info_tcnt++ << "/" << info_tmax << '\r';
            std::cout.flush();

            FILE* fp = fopen(it->c_str(), "rb");

            if (!fp) {
                throw CException("NodeJsCoverageReaderPlugin::readFromDirectory", "Cannot open file: " + it->string());
            }

            std::ifstream ins(it->c_str());
            rapidjson::IStreamWrapper isw(ins);
            rapidjson::Document json;
            json.ParseStream(isw);

            if(!json.IsObject()) {
                throw CException("NodeJsCoverageReaderPlugin::readFromDirectory", "Cannot parse JSON file: " + it->string());
            }

            String tcname = fs::basename(*it);
            boost::algorithm::trim(tcname);

            m_coverage->addTestcaseName(tcname);
            m_coverage->refitMatrixSize();

            switch (m_granularity) {
                case CHAIN: readChainCoverage(tcname, json); break;
                case METHOD: readFunctionCoverage(tcname, json); break;
                default: break;
            }
        }
    }
}

void NodeJsCoverageReaderPlugin::readChainCoverage(const std::string& tcname, const rapidjson::Document& json) {
    auto nodes = json.FindMember("nodes");

    std::map<int, std::string> id_to_codeElement_mapping;

    for (auto& item : nodes->value.GetArray()) {
        auto id = item["id"].GetInt();

        String pos = item["pos"].GetString();
        pos = boost::regex_replace(pos, m_codeElementNameFilter, "");

        id_to_codeElement_mapping[id] = pos;
    }

    auto chains = json.FindMember("call_chains");

    for (auto& chain : chains->value.GetArray()) {
        std::vector<String> code_elements;

        for (auto& id : chain.GetArray()) {
            auto name = id_to_codeElement_mapping[id.GetInt()];

            code_elements.push_back(name);
        }

        auto chain_as_string = boost::algorithm::join(code_elements, "---");

        m_coverage->addOrSetRelation(tcname, chain_as_string);
    }
}

void NodeJsCoverageReaderPlugin::readFunctionCoverage(const std::string& tcname, const rapidjson::Document& json) {
    auto nodes = json.FindMember("nodes");

    std::map<int, std::string> id_to_codeElement_mapping;

    for (auto& item : nodes->value.GetArray()) {
        auto id = item["id"].GetInt();

        String pos = item["pos"].GetString();
        pos = boost::regex_replace(pos, m_codeElementNameFilter, "");

        id_to_codeElement_mapping[id] = pos;

        m_coverage->addCodeElementName(pos);
    }

    m_coverage->refitMatrixSize();

    auto chains = json.FindMember("call_chains");

    std::set<String> covered_codeElements;

    for (auto& chain : chains->value.GetArray()) {
        for (auto& id : chain.GetArray()) {
            auto name = id_to_codeElement_mapping[id.GetInt()];

            covered_codeElements.insert(name);
        }
    }

    for (auto& codeElement : covered_codeElements) {
        m_coverage->setRelation(tcname, codeElement);
    }
}


extern "C" MSDLL_EXPORT void registerPlugin(CKernel &kernel)
{
    kernel.getCoverageReaderPluginManager().addPlugin(new NodeJsCoverageReaderPlugin());
}

} /* namespace soda */
